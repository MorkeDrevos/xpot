// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ─────────────────────────────────────────────
// Enums
// ─────────────────────────────────────────────

enum TicketStatus {
  IN_DRAW
  WON
  CLAIMED
  NOT_PICKED
  EXPIRED
}

enum BonusDropStatus {
  SCHEDULED
  FIRED
  CANCELLED
}

enum WinnerKind {
  MAIN
  BONUS
}

enum OpsMode {
  MANUAL
  AUTO
}

// ─────────────────────────────────────────────
// Models
// ─────────────────────────────────────────────

// Single-row config table (stores ops mode etc)
model OpsConfig {
  // enforce exactly one row via stable primary key
  singleton String @id @default("singleton")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  mode OpsMode @default(MANUAL)
}

// User identity (Clerk/X). Tickets are NOT owned by User, they are owned by Wallet.
model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Clerk identity
  clerkId String? @unique

  // X identity (optional)
  xUserId    String? @unique
  xHandle    String? @unique
  xName      String?
  xAvatarUrl String?

  // Linked wallets (optional)
  wallets Wallet[]

  @@index([xHandle])
  @@index([clerkId])
}

// Wallet -> owns tickets
model Wallet {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  address String @unique

  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  tickets Ticket[]

  @@index([userId])
}

// Daily XPOT draw
model Draw {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  /// Calendar date bucket (your server decides the bucket rules)
  drawDate DateTime @unique

  /// When the main XPOT closes for entries
  closesAt DateTime?

  /// open | closed | completed (kept string to avoid enum migrations during iteration)
  status String @default("open")

  tickets    Ticket[]
  winners    Winner[]
  bonusDrops BonusDrop[]

  // Public lobby entrants for this draw (X handles)
  entries DrawEntry[]
}

// XPOT ticket in a draw
model Ticket {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  code String @unique

  // Ticket must always have an owning wallet
  walletId String
  wallet   Wallet @relation(fields: [walletId], references: [id], onDelete: Cascade)

  // Snapshot of wallet address at creation time (rendering + audit)
  walletAddress String
  status        TicketStatus @default(IN_DRAW)

  drawId String
  draw   Draw @relation(fields: [drawId], references: [id], onDelete: Cascade)

  winners Winner[]

  @@index([walletId])
  @@index([drawId])
  @@index([status])
  @@index([walletAddress])

  // Prevent duplicate tickets per wallet per draw
  @@unique([walletId, drawId])
}

// Log of main + bonus winners
model Winner {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  drawId String
  draw   Draw @relation(fields: [drawId], references: [id], onDelete: Cascade)

  ticketId String
  ticket   Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  // Optional extra timestamp (you already have createdAt)
  date DateTime @default(now())

  // Snapshots (fast + stable rendering)
  ticketCode    String
  walletAddress String

  jackpotUsd Float   @default(0)
  payoutUsd  Float   @default(0)
  isPaidOut  Boolean @default(false)
  txUrl      String?

  kind  WinnerKind @default(MAIN)
  label String?

  @@index([drawId])
  @@index([ticketId])
  @@index([isPaidOut])
  @@index([kind])
  @@index([walletAddress])
}

// Scheduled bonus XPOT drops
model BonusDrop {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  drawId String
  draw   Draw @relation(fields: [drawId], references: [id], onDelete: Cascade)

  label       String
  amountXpot  Int
  scheduledAt DateTime

  status BonusDropStatus @default(SCHEDULED)

  @@index([drawId])
  @@index([status, scheduledAt])
}

// Public lobby entry (X handle) for a specific draw
model DrawEntry {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  drawId String
  draw   Draw @relation(fields: [drawId], references: [id], onDelete: Cascade)

  // Clerk user id (string) - reliable even if User row doesn't exist yet
  clerkId String

  // Public identity (by handle)
  xHandle    String
  xName      String?
  xAvatarUrl String?
  followers  Int?
  verified   Boolean?

  // One entry per user per draw
  @@unique([drawId, clerkId])

  // Optional: uncomment if you want "1 handle = 1 entry" per draw
  // @@unique([drawId, xHandle])

  @@index([drawId, createdAt])
  @@index([xHandle])
  @@index([clerkId])
}

// ─────────────────────────────────────────────
// Missing models (these MUST exist if your routes use prisma.hubStreak / prisma.userPreference)
// ─────────────────────────────────────────────

// Hub streak tracking (used by /api/hub/streak)
model HubStreak {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // used by upsert where: { clerkId }
  clerkId String @unique

  // consecutive days
  days Int @default(0)

  // the last day bucket recorded (you can store UTC-midnight or your own bucket)
  lastDoneDay DateTime?

  @@index([clerkId])
}

// User preferences (used by /api/me/preferences)
model UserPreference {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // used by upsert where: { clerkId }
  clerkId String @unique

  soundEnabled Boolean @default(true)

  @@index([clerkId])
}
